use crate::{Buffer, Device, HasId, HasModules, OnDropBuffer, PtrType, Shape, WrappedData, CPU};

use super::storages::{CpuStorage, CudaStorage, UntypedData};

#[cfg(feature = "cuda")]
pub type Cuda<Mods> = crate::CUDA<Mods>;

#[cfg(not(feature = "cuda"))]
pub type Cuda<Mods> = super::CUDA<Mods>;

pub enum UntypedDevice<Mods> {
    CPU(CPU<Mods>),
    CUDA(Cuda<Mods>),
}

pub struct Untyped<Mods> {
    device: UntypedDevice<Mods>,
}

impl<Mods: OnDropBuffer> Device for Untyped<Mods> {
    type Base<T, S: crate::Shape> = UntypedData;
    type Data<T, S: crate::Shape> = Mods::Wrap<T, UntypedData>;
    type Error = ();

    #[inline]
    fn base_to_data<T, S: crate::Shape>(&self, base: Self::Base<T, S>) -> Self::Data<T, S> {
        self.wrap_in_base(base)
    }

    #[inline]
    fn wrap_to_data<T, S: crate::Shape>(
        &self,
        wrap: Self::Wrap<T, Self::Base<T, S>>,
    ) -> Self::Data<T, S> {
        wrap
    }

    #[inline]
    fn data_as_wrap<'a, T, S: crate::Shape>(
        data: &'a Self::Data<T, S>,
    ) -> &'a Self::Wrap<T, Self::Base<T, S>> {
        data
    }

    #[inline]
    fn data_as_wrap_mut<'a, T, S: crate::Shape>(
        data: &'a mut Self::Data<T, S>,
    ) -> &'a mut Self::Wrap<T, Self::Base<T, S>> {
        data
    }
}

impl<Mods> HasModules<Mods> for Untyped<Mods> {
    #[inline]
    fn modules(&self) -> &Mods {
        match &self.device {
            UntypedDevice::CPU(cpu) => &cpu.modules,
            UntypedDevice::CUDA(cuda) => &cuda.modules,
        }
    }
}

// Typically, these are generated by a macro
// TODO However, they would require to use the .modules() function

impl<Mods: WrappedData + OnDropBuffer> OnDropBuffer for Untyped<Mods> {
    #[inline]
    fn on_drop_buffer<T, D: Device, S: Shape>(&self, device: &D, buf: &Buffer<T, D, S>) {
        self.modules().on_drop_buffer(device, buf)
    }
}

impl<Mods: WrappedData> WrappedData for Untyped<Mods> {
    type Wrap<T, Base: HasId + PtrType> = Mods::Wrap<T, Base>;

    #[inline]
    fn wrap_in_base<T, Base: crate::HasId + crate::PtrType>(
        &self,
        base: Base,
    ) -> Self::Wrap<T, Base> {
        self.modules().wrap_in_base(base)
    }

    #[inline]
    fn wrapped_as_base<T, Base: crate::HasId + crate::PtrType>(
        wrap: &Self::Wrap<T, Base>,
    ) -> &Base {
        Mods::wrapped_as_base(wrap)
    }

    #[inline]
    fn wrapped_as_base_mut<T, Base: crate::HasId + crate::PtrType>(
        wrap: &mut Self::Wrap<T, Base>,
    ) -> &mut Base {
        Mods::wrapped_as_base_mut(wrap)
    }
}
